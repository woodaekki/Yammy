stages:
  - Test_Build
  - FE_Image
  - BE_Image
  - Deploy

variables:
  ECR_REPOSITORY_URI: 725115073641.dkr.ecr.ap-northeast-2.amazonaws.com/yammy
  APP_DIR: .
  FRONTEND_DIR: Yammy-FE
  BACKEND_DIR: Yammy-BE/yammy

# =========================================================
# 🎯 Test_Build_BE: 테스트 환경 구성 및 빌드 (확인 대상)
# =========================================================
Test_Build_BE:
  stage: Test_Build
  image: openjdk:17-jdk-slim
  tags:
    - test-build # docker executore를 사용하는 새로 생성된 러너
  services:
    - name: mysql:8.0
      alias: mysql-db
    - name: redis:latest
      alias: redis

  variables:
    # 1. MySQL 서비스 컨테이너 자체 설정 변수
    MYSQL_DATABASE: testdb
    MYSQL_ROOT_PASSWORD: root_password

    # 2. Spring Boot가 참조할 환경 변수 (GitLab CI에서 조합)
    DB_URL: jdbc:mysql://mysql-db:3306/${MYSQL_DATABASE}?serverTimezone=Asia/Seoul
    DB_USERNAME: root
    DB_PASSWORD: ${MYSQL_ROOT_PASSWORD}

    SPRING_DATA_REDIS_HOST: redis
    SPRING_DATA_REDIS_PORT: 6379
    SPRING_DATA_REDIS_PASSWORD:

    # 추가 변수들은 GitLab CI/CD Variables에 등록되어 사용된다고 가정

  before_script:
    - cd ${BACKEND_DIR}
    - chmod +x gradlew

    - apt-get update -qq && apt-get install -y --no-install-recommends wait-for-it
    - wait-for-it mysql-db:3306 -t 30 -- echo "MySQL is up and running!"
    - wait-for-it redis:6379 -t 30 -- echo "Redis is up and running!"

    - | 
      MYSQL_HOST_IP=$(getent hosts mysql-db | awk '{ print $1 }');
      if [ -z "$MYSQL_HOST_IP" ]; then 
        MYSQL_HOST_IP="mysql-db"; # IP를 찾지 못하면 alias 사용 (wait-for-it이 성공했으므로 시도)
      fi;
      export DB_URL=jdbc:mysql://${MYSQL_HOST_IP}:3306/${MYSQL_DATABASE}?serverTimezone=Asia/Seoul

    - export DB_URL=$DB_URL
    - export DB_USERNAME=$DB_USERNAME
    - export DB_PASSWORD=$DB_PASSWORD
    - rm -f src/main/resources/application.yml
    - echo "$CI_APPLICATION_YML" > src/main/resources/application.yml
    - echo "application.yml created successfully with CI variables."

  script:
    - ./gradlew clean build

  artifacts:
    when: on_success
    paths:
      - ${BACKEND_DIR}/build/libs/*.jar
    expire_in: 1 week

FE_Image:
  stage: FE_Image
  image: docker:24.0.5
  tags:
    - test-build
  services:
    - name: docker:24.0.5-dind

  variables:
    FE_IMAGE_TAG: frontend-latest
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""

  script:
    - cd ${FRONTEND_DIR}

    - apk add --no-cache python3 py3-pip
    - pip install awscli
    - export AWS_ACCESS_KEY_ID
    - export AWS_SECRET_ACCESS_KEY
    - export AWS_DEFAULT_REGION
    - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI

    - docker build -t $ECR_REPOSITORY_URI:$FE_IMAGE_TAG .
    - docker push $ECR_REPOSITORY_URI:$FE_IMAGE_TAG

BE_Image:
  stage: BE_Image
  image: docker:24.0.5
  tags:
    - test-build
  services:
    - name: docker:24.0.5-dind

  dependencies:
    - Test_Build_BE

  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    BE_IMAGE_TAG: backend-latest
    PROD_APPLICATION_YML: $PROD_APPLICATION_YML # GitLab CI/CD Variables에 등록된 운영 YML 내용

  script:
    - cd ${BACKEND_DIR}

    - rm -f src/main/resources/application.yml
    - echo "$PROD_APPLICATION_YML" > src/main/resources/application-prod.yml

    - apk add --no-cache python3 py3-pip
    - pip install awscli
    - export AWS_ACCESS_KEY_ID
    - export AWS_SECRET_ACCESS_KEY
    - export AWS_DEFAULT_REGION
    - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPOSITORY_URI

    - docker build -t $ECR_REPOSITORY_URI:$BE_IMAGE_TAG .
    - docker push $ECR_REPOSITORY_URI:$BE_IMAGE_TAG

# --- Deploy Stage ---
Deploy:
  stage: Deploy
  tags:
    - shell-deploy
  image: alpine/ssh:latest

  variables:
    DEPLOY_HOST: $EC2_HOST      # EC2 인스턴스 Public IP 주소
    DEPLOY_USER: $EC2_USERNAME             # EC2 접속 사용자 이름
    DEPLOY_KEY: $EC2_PRIVATE_KEY      # SSH 프라이빗 키

    # DB/이미지 정보 (docker-compose.yml에 주입할 값)
    DB_URL: $DB_URL
    DB_USERNAME: $DB_USERNAME
    DB_PASSWORD: $DB_PASSWORD
    DB_NAME: $DB_USERNAME

    # ECR 및 이미지 정보 (전역 변수를 다시 Job 변수로 끌어옴)
    ECR_REPOSITORY_URI: $ECR_REPOSITORY_URI
    BE_IMAGE_URI: $ECR_REPOSITORY_URI:backend-latest
    FE_IMAGE_URI: $ECR_REPOSITORY_URI:frontend-latest
    AWS_DEFAULT_REGION: $AWS_DEFAULT_REGION # ECR 로그인에 필요

  before_script:
    # 1. SSH 키 설정 (GitLab CI/CD Variables에 등록된 키를 사용)
    - eval $(ssh-agent -s)
    - echo "$DEPLOY_KEY" | tr -d '\r' | ssh-add - > /dev/null
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $DEPLOY_HOST >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

    # 2. ⭐️ SSH 접속하여 실행할 명령어 묶음 정의 ⭐️
    - |
      SSH_COMMAND="
        # 2-1. GitLab Variables의 값을 EC2 쉘 환경 변수로 설정 (docker-compose 참조용)
        # 이 변수들은 EC2의 docker-compose.yml 파일에 주입됩니다.
        export DB_URL='$DB_URL';
        export DB_USERNAME='$DB_USERNAME';
        export DB_PASSWORD='$DB_PASSWORD';
        export ECR_REPOSITORY_URI='$ECR_REPOSITORY_URI';
        export BE_IMAGE_URI='$BE_IMAGE_URI';
        export FE_IMAGE_URI='$FE_IMAGE_URI';
      
        # 2-2. ECR 로그인 (EC2 호스트의 AWS CLI와 Docker 사용)
        # ⚠️ EC2 인스턴스에 AWS CLI 설치 및 Docker 서비스가 실행 중이어야 합니다.
        aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin \$ECR_REPOSITORY_URI;
      
        # 2-3. 최신 이미지 Pull (Downtime 최소화를 위해 Pull 먼저 실행)
        docker pull \$BE_IMAGE_URI;
        docker pull \$FE_IMAGE_URI;

        # 2-4. Docker Compose 실행: 최신 이미지를 사용하여 서비스 업데이트
        # DB 컨테이너는 데이터 보존을 위해 삭제/재생성되지 않고 업데이트됩니다.
        # -f /home/ubuntu/docker-compose.yml 파일이 존재해야 합니다.
        docker-compose -f /home/ubuntu/docker-compose.yml up -d --force-recreate
      "

  script:
    # ⭐️ 3. SSH 접속 및 배포 명령 실행 ⭐️
    # '-o StrictHostKeyChecking=no'는 보안 위험이 있어 keygen으로 대체했습니다.
    - ssh $DEPLOY_USER@$DEPLOY_HOST "$SSH_COMMAND"

